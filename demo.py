import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import KMeans
from hmmlearn import hmm

# -------------------------------------------------
# 1. 业务给定数据
# -------------------------------------------------
# 1-a 隐藏状态（组件）
COMPONENTS = [
    "组件名称: 账户详情查询",
    "组件名称: 现金存款",
    "组件名称: 个人活期账户销户",
    "组件名称: 查询账户币种",
    "组件名称: 查询证件类型",
    "组件名称: 生成身份证号码",
    "组件名称: 查询账户编号",
    "组件名称: 账户信息查询",
    "组件名称: 登录",
    "组件名称: 提任务",
    "组件名称: 查询测管用户",
    "组件名称: 查询正常的个人活期存款账户编号",
    "组件名称: 查询零存整取账户编号",
    "组件名称: 查询教育储蓄账户编号",
    "组件名称: 查询二类账户编号",
    "组件名称: 查询三类账户编号",
    "组件名称: 查询冻结的个人活期存款账户编号",
    "组件名称: 查询挂失的个人活期存款账户编号",
    "组件名称: 查询销户的个人活期存款账户编号",
    "组件名称: 查询个人支票账户编号",
    "组件名称: 查询正常的个人保证金活期账户编号"
]
state2id = {s: idx for idx, s in enumerate(COMPONENTS)}
N_states = len(COMPONENTS)

# 1-b 转移概率 EDGES → A 矩阵
EDGES = [
    ("组件名称: 登录", "组件名称: 查询账户编号", 0.8),
    ("组件名称: 登录", "组件名称: 提任务", 0.2),
    ("组件名称: 查询账户编号", "组件名称: 账户详情查询", 0.7),
    ("组件名称: 查询账户编号", "组件名称: 账户信息查询", 0.3),
    ("组件名称: 账户详情查询", "组件名称: 现金存款", 0.6),
    ("组件名称: 账户详情查询", "组件名称: 个人活期账户销户", 0.4),
    ("组件名称: 现金存款", "组件名称: 账户详情查询", 0.9),
    ("组件名称: 个人活期账户销户", "组件名称: 查询销户的个人活期存款账户编号", 0.5),
    ("组件名称: 提任务", "组件名称: 查询测管用户", 0.7),
    ("组件名称: 查询测管用户", "组件名称: 生成身份证号码", 0.4),
    ("组件名称: 生成身份证号码", "组件名称: 查询证件类型", 0.6),
    ("组件名称: 查询证件类型", "组件名称: 查询账户币种", 0.5),
    ("组件名称: 查询账户币种", "组件名称: 查询正常的个人活期存款账户编号", 0.8),
    ("组件名称: 查询正常的个人活期存款账户编号", "组件名称: 查询零存整取账户编号", 0.3),
    ("组件名称: 查询零存整取账户编号", "组件名称: 查询教育储蓄账户编号", 0.4),
    ("组件名称: 查询教育储蓄账户编号", "组件名称: 查询二类账户编号", 0.5),
    ("组件名称: 查询二类账户编号", "组件名称: 查询三类账户编号", 0.6),
    ("组件名称: 查询三类账户编号", "组件名称: 查询冻结的个人活期存款账户编号", 0.2),
    ("组件名称: 查询冻结的个人活期存款账户编号", "组件名称: 查询挂失的个人活期存款账户编号", 0.3),
    ("组件名称: 查询挂失的个人活期存款账户编号", "组件名称: 查询销户的个人活期存款账户编号", 0.4),
    ("组件名称: 查询销户的个人活期存款账户编号", "组件名称: 查询个人支票账户编号", 0.5),
    ("组件名称: 查询个人支票账户编号", "组件名称: 查询正常的个人保证金活期账户编号", 0.6)
]

A = np.zeros((N_states, N_states))
for from_s, to_s, p in EDGES:
    A[state2id[from_s], state2id[to_s]] = p
# 行归一化
for i in range(N_states):
    if A[i].sum() == 0:          # 孤立节点
        A[i, i] = 1.0            # 自环
    else:
        A[i] /= A[i].sum()       # 行归一化

# -------------------------------------------------
# 2. 构造训练数据
# -------------------------------------------------
# 2-a 原始会话文本（用户问句）
raw_sentences = [
    "登录&&核心系统&&",
    "进入<存款账户信息查询>交易，查询账户A的当前余额为Y元",
    "进入<个人现金存款>交易",
    "输入账户A账号和金额X元",
    "提交交易，交易成功",
    "进入<存款账户信息查询>交易，查询账户A的当前余额增加X元"
]

# 2-b 人工/日志给出的隐藏状态标签（与 COMPONENTS 对齐）
state_labels = [
    state2id["组件名称: 登录"],
    state2id["组件名称: 账户详情查询"],
    state2id["组件名称: 现金存款"],
    state2id["组件名称: 现金存款"],
    state2id["组件名称: 现金存款"],
    state2id["组件名称: 账户详情查询"]
]

# -------------------------------------------------
# 3. 向量化 + 聚类
# -------------------------------------------------
vec = TfidfVectorizer(max_features=500, min_df=1)
X = vec.fit_transform(raw_sentences).toarray()

K = min(len(raw_sentences), 8)
kmeans = KMeans(n_clusters=K, random_state=42).fit(X)
obs_id = kmeans.predict(X)          # shape = (6,)

# -------------------------------------------------
# 4. 训练离散 HMM
# -------------------------------------------------
model = hmm.MultinomialHMM(n_components=N_states,
                           n_iter=20,
                           init_params='ste')   # 不随机初始化
# 注入已知的 A、Pi
model.startprob_ = np.zeros(N_states)
model.startprob_[state2id["组件名称: 登录"]] = 1.0
model.transmat_ = A
# 为了让 hmmlearn 学习发射矩阵，把 obs_id 传进去
model.fit(obs_id.reshape(-1, 1), lengths=[len(obs_id)])

# -------------------------------------------------
# 5. 线上推理函数
# -------------------------------------------------
def predict_path(new_question: str):
    x = vec.transform([new_question]).toarray()
    c = kmeans.predict(x)[0]
    logprob, seq = model.decode(np.array([[c]]), algorithm="viterbi")
    return [COMPONENTS[i] for i in seq]

# -------------------------------------------------
# 6. 演示
# -------------------------------------------------
print("=== 训练观测序列 ===")
for txt, st in zip(raw_sentences, state_labels):
    print(f"{txt[:40]:<40s} → {COMPONENTS[st]}")

print("\n=== 推理示例 ===")
q = "现金存款"
path = predict_path(q)
print(f"问句：{q}")
print("最可能隐藏状态链：")
for st in path:
    print("  ", st)